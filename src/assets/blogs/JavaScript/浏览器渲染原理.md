#### 浏览器如何渲染

##### render

- 本质：html -> pixel

##### 流程

1. 解析 (DOM 树 & CSSOM 树)

   > - document -> head / body
   > - StyleSheetList -> CSSStyleSheet -> CSSRule
   > - 会启动`预解析器`下载和解析 CSS

2. 计算样式

   > - 遍历 DOM 树，计算每个节点的最终样式(预设值转化成绝对值)，即 Computed Style

3. 布局

   > - 遍历 DOM 树，确定每个节点的几何信息，如宽高、相对于包含块的位置等
   > - DOM 树与 Layout 树不一定一一对应(可能有隐藏元素/伪元素)

4. 分层

   > - 当某一层改变后，仅会对该层进行后续处理，从而`提升效率`

5. 绘制

   > - 渲染主线程工作`到此结束`
   > - 生成一系列`绘制指令`

6. 分块

   > - 每一层分成多个小区域，例如`优先渲染靠近视口的块`

7. 光栅化

   > - 合成线程将每个块交由 GPU 进程 变成位图

8. 画
   > - 生成 quad (指引信息)

##### 回流 reflow

- 当进行了会影响 Layout 树的操作后，需要重新计算
- 多次连续操作会被合并成统一计算，导致 reflow 是`异步操作`
- 当读取几何信息时，会立即 reflow
- 触发回流的情况：
  > - 首次渲染
  > - 改变窗口大小
  > - 改变元素几何信息(宽高、位置、margin、padding、border 等)
  > - 元素增、删、隐藏
  > - 修改文本内容、字体大小

##### 重绘 repaint

- 当改动了可见样式后，需要重新计算，引发 repaint
- 本质是重新计算了绘制指令
- 触发重绘的情况：
  > - 改变元素的颜色、背景色、透明度等只影响视觉外观的属性
  > - 使用 CSS 动画或过渡效果

##### 针对回流和重绘的页码性能优化

- 使用 CSS3 动画而非 JS 实现动画
- 使用 Transform 和 Transition 实现动画，触发 GPU 加速，减少开销
- 避免频繁操作 DOM，可以批量操作或者文档分段
- 使用性能更好的 Flex 和 Grid 布局
- 使用 debounce 或 throttle 函数

#### 1 概述

JavaScript 引擎的事件循环（event loop）是一种机制，是浏览器`渲染主线程`的工作方式，用于处理异步代码和任务调度，以确保 JavaScript 在单线程执行的环境中能够处理异步操作而不会阻塞主线程。
Chrome 等浏览器会开启一个`死循环`，每次循环从消息队列中去调度任务。
宏任务和微任务的分类方式不再满足现有环境，取而代之的是`按照类型对任务分类`，微任务的优先级最高，其余由浏览器决定

#### 2 步骤

1. `执行同步代码`： 首先，JavaScript 引擎会执行调用栈中的同步代码，直到调用栈为空。

2. `处理微任务`： 当同步代码执行完毕后，引擎会检查微任务队列。如果微任务队列不为空，它会依次执行微任务，直到队列为空。

3. `执行其余异步任务`： 在处理完所有的微任务后，引擎会检查其余任务队列，选择一个宏任务（如定时器回调、事件回调）来执行。执行宏任务的过程会将相关的同步代码推入调用栈。

4. 进入下一个循环

#### 3 浏览器进程模型

##### 3.1 进程

- 进程：分配内存空间
- 每个标签页都会运行在独立的进程中，提供隔离性、安全性和稳定性 Process-per-tab
- 未来趋势：一个站点一个进程
- `浏览器进程`（处理用户界面、用户交互、子进程管理）、`网络进程`、`渲染进程`、`JS 引擎进程`等）

##### 3.2 线程

- 线程：分配具体任务
- 每个进程至少包含一个主线程和 0-n 个副线程
- `渲染主线程`：从任务队列中调度任务

#### 4 异步

- JS 单线程执行，而渲染主线程只有一个（负责 HTML 和 CSS 解析、布局、渲染、计时器回调、事件回调等任务），引入异步避免主线程阻塞，异步任务会被添加到事件队列，然后按照微任务、宏任务的调度策等待主线程调度执行

- 类型
  - 计时完成后执行 setTimeout setInterval
  - 网络通信完成后执行 XHR
  - 用户操作后执行 addEventListener

#### 5 任务有优先级吗？

- `任务没有优先级`，但是`消息队列有优先级`
- 同类型任务必须排序同一个队列，不同类型的任务可以分属不同的队列
- 主要的队列：
  - 微队列：存放需要最快执行的任务，优先级【最高】`Promise.resolve().then(fun)`
  - 交互队列：存放用户操作后的回调任务，优先级【高】
  - 延时队列：存放计时器到达后的回调任务，优先级【中】

#### 6 微任务和宏任务

- 微任务（microtask）`Promise、process.nextTick 和 MutationObserver 等`
- 宏任务（macrotask）`setTimeout、setInterval、 requestAnimationframe和 XHR等`
